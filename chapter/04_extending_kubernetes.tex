\chapter{Extending Kubernetes}

This chapter is about how to extend Kubernetes.
There are several ways to extend Kubernetes, this chapter focuses on Custom Resources and Controllers.

\section{Operator pattern}\label{sec:operator-pattern}

Operators are software that integrates in Kubernetes and manage applications.
The name originates from the fact that the software performs the tasks of a human operator.
The operator knows the system and how to deploy and configure it for different scenarios and at scale.~\cite{KUBERNETES-OPERATOR}
\\
A system admin knows about the software, takes care of the deployment, monitoring and backups.
With the advent of the DevOps movement, this tradition has changed dramatically.
The management of applications, monitoring, backups, and entire cloud environments has been centralized and versioned using Infrastructure as Code.
With containers, the deployment of applications has been standardized.
However, a sysadmin is still required to react to state changes, that happen frequently inside a cloud native environment.
The operator therefore acts as a kind of robot sysadmin who can react directly to changes.~\cite{RED-HAT-OPERATOR}

\section{Custom Resource Definitions}\label{sec:custom-resource-definitions}

In Kubernetes \textit{Custom Resource Definitions}, in short CRDs, are used to extend the Kubernetes API.
A resource is a kubernetes API endpoint, like a Pod or Deployment.
These endpoints and data structures are predefined by Kubernetes.
A Custom Resource extends this, with its own endpoint and data structure.
This allows data to be stored within the cluster.
Custom resources can be registered and de-registered at runtime.~\cite{KUBERNETES-CRD}

\section{Controllers}\label{sec:controllers}
A controller implements a control loop that constantly monitors the status of the cluster.
Depending on whether a certain change takes place, the controller reacts and makes adjustments where needed.
\\
The controller observes at least one Kubernetes resource.
The spec field within the resource represents the desired state.
Based on this, the controller tries to establish the desired state in the cluster.
So the goal of a controller is to bring the status of a cluster into the desired state.
\\
This is mostly done by calls to the Kubernetes API, but can also be brought about by external API calls, this is called direct control.
Since the state of external resources is not available within Kubernetes, such controllers usually use a status field, which is part of the Kubernetes resource, to reflect it in the cluster.
Other controllers can monitor this and then react in turn.
\\
To implement the Operator pattern, a custom controller is required.
~\cite{KUBERNETES-CONTROLLERS}